# cha01 体现表达力
    1). 消除重复
    2). 提高表达力

# cha02 有意义的命名
    1.变量/函数/类的名称->为什么会存在,做什么事.应该怎么用
    2.提防使用 不同之处较小 的名称
    3.废话:
        没有意义的区分 ProductInfo<->ProductData
        冗余:变量名有variable,表明有Table,NameString<->Name,Customer<->CustomerObject
    4. 7 <-> MAX_STUDENT_COUNT
    5. 	类名: 名词或者名词短语 
    	方法名:  动词或动词短语
    			重载构造器是,使用描述了参数的静态工厂方法名,把相应的构造器设置为private!
        Complex fulcrumPoint = Complex.FromRealNumber(23.0) | 好
        Complex fulcrumPoint = new Complex(23.0); | 不好 应该设为private
    6. 不要用双关语 add 可以分成 insert append....
    7. 添加有意义的语境: state->addrState


​    			
# cha03 函数

1. 短小
2. 只做一件事 做好这件事
3. 在同一个抽象趁机->便于判断表达式是基础概念还是细节,不要混乱
4. 确保switch在较低的抽象层级,可以利用多态实现
5. 尽量避免三个及以上参数的函数
6. 如果函数要对输入参数进行转换,转换结果就体现为返回值
7. 函数需要两个,三个会三个以上参数,其中一些参数应该封装为类了
8. write(name)->writeField(name) name是一个field
   assertEqual->assertExpectedEqualsActual(expected, actual)
9. 函数只做一件事,要没有未能预期的改动
10. 避免使用输出参数,如果要修改状态,最好修改所属对象的状态
11. 函数要么做事,要么回答事->指令与询问分割开来
12. 用异常代替返回错误码->避免if嵌套
13. 用异常代替错误码,新异常就可以从异常类派生,不需要重新编译或重新部署
14. 消除重复的代码
15. 一开始写函数都冗长而复杂, 后面再按照规则写函数

# cha04 注释
1. 好注释: 提供基本信息(某个抽象方法的返回值)->提供某个决定后面的意图->
2. 警示: 警告会出现某种后果
3. 放大:放大不合理之物的重要性
4. Javadoc
5. 假如每个函数都有Javadoc就有废话搞乱代码
6. 少用标记栏(>>>>>>>>>>>>> \\\\\\\\\\\\) 滥用标记栏,就会沉没在背景噪音中,被忽略掉
7. 在括号后面打上注释标记函数->编写更小的函数
8. 不要归属与署名,用版本工具
9. 不要注释代码->版本控制工具会记住不要的代码
10. 注释描述离它最近的代码
11. 非公共代码不要Javadoc

# cha05 格式

1. 空白行隔开了概念;紧密相关的代码应该互相靠近
2. 不要把关系密切的概念放到不同的文件中(也不要用protected)
3. 循环中的控制变量应该在循环语句中声明
4. 实体变量应该在类的顶部生命
5. 若一个函数调用了另外一个,就应该把它们放到一起; 调用者尽可能在被调用者上面
6. 等式具有较高优先级,之间不加空格
7. 短小的if语句也要缩进,避免范围层级塌到一行

# cha06 对象和数据结构

1. 隐藏实现关乎抽象,类并不简单地用getter和setter将变量推向外键,而是暴露接口,以便用户无需了解数据的实现就能操作数据本体

2. 
|      | 过程式 | 面向对象 |
| ---- | ------ | -------- |
| 优点 | 不改动既有数据结构的前提下添加新函数 | 不改动既有函数的前提下添加新类 |
| 缺点 | 难以添加新数据结构 | 难以添加新函数 |

3. The law of Demeter: 对象隐藏数据,暴露操作

   ```java
   final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath()
   // 这种使用方法不好,调用了由其他函数返回的对象的方法  
   //通过getter暴露了内部的数据结构. 这些方法中既有执行操作的函数，也有公共的变量
   //可以改为ctx对象来获取这个路径
   ```
   ```mermaid
   graph LR
   A[类X的方法f] -->|调用| B(类X)
    A -->|调用| C(f创建的对象)
    A -->|调用| D(作为参数传递给f的对象)
    A -->|调用| E(X的实体变量持有的对象)
   ```


# cha07 错误处理

1. 使用异常而不是返回码
   	返回码使得调用之后需要立刻检查错误,容易被遗忘
   
2. 先写try-catch-finally, 帮助定义用户应该得到什么结果

3. 使用不可控异常
   可控异常：每个方法都要列出它可能传递给调用者的所有异常。并且这些异常是函数类型的一部分，如果签名与代码所做的实际之事不合，则不能通过编译。可控异常不好的地方就是你对一个异常要层层声明，会破坏开放封闭原则。
   
4. 异常包含足够的环境说明: 失败的操作和失败类型

5. 打包调用API,返回通用异常类型简化代码. 不然就有很多很多catch代码

6. 特例模式->创建一个类或者配置一个对象,用来处理特例.客户代码不用处理异常,异常封装到了特例对象

7. 不要返回null

   返回null值,就需要检查null,增加工作量

   不如抛出异常或者返回特例对象

   空list->Collections.emptyList()

   对于第三方API,用新方法打包这个方法,在新方法中抛出异常或者返回特例对象

8. 不要传递null值,大部分编程语言没有良好的方法对付调用者意外传入null值

# cha08: 边界

1. 使用第三方代码:

   ``` java
   public class Sensoes{
       private Map sensors = new HashMap();
       
       public Sensor getById(String id) {
           return (Sensor) sensors.get(id);
       }
   }
   //整洁的实现方式,用户不必关系是否用了泛型
   //Map隐藏了
   ```

   如果使用类似Map这样的边界接口,就把它保留在类或者近亲类中（封装 Map 的使用到类中）. 避免冲公共API中返回边界接口,或将接口作为参数传递给贡藕给你API

# cha09: 单元测试

1. TDD 三定律:

   1. 在编写不能通过的单元测试前,不编写生产代码
   2. 只可编写刚好无法通过的单元测试,不能编译也不算通过
   3. 只可编写刚好足以通过当前失败测试的生产代码

2. 脏测试等同于没测试,问题在于测试必须随着生产代码的演进而修改

   测试代码和生产代码一样重要,需要被设计,保持整洁

3. P131 测试带来的好处

